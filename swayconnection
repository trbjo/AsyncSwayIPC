#!/usr/bin/python

import asyncio
from asyncio import Task
from signal import SIGINT, SIGTERM, SIGUSR1

from core import get_ipcs
from event_handler import event_handler
from misc import set_appstate
from tasks import periodically_pause, signal_invisible, update_for_battery_status


async def main(appstate: dict) -> None:
    subscriptions: dict[str, dict[str, bool]] = appstate["subscriptions"]
    subscription_types = [
        sub
        for sub, subdict in subscriptions.items()
        if any(k for k in subdict.values())
    ]

    async with get_ipcs() as connection:
        appstate["connection"] = connection
        task = asyncio.create_task(event_handler(appstate))
        await connection.subscribe(subscription_types)
        while True:
            try:
                event, subevent = await connection.listen()
                if subscriptions[event][subevent]:
                    task.cancel()
                    task = asyncio.create_task(event_handler(appstate))

            except asyncio.CancelledError:
                print("shutting down from main")
                await signal_invisible(appstate, respect_hibernate=False, sleep=False)
                return


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    appstate = asyncio.run(set_appstate())
    loop.add_signal_handler(
        SIGUSR1, lambda: asyncio.create_task(update_for_battery_status(appstate))
    )

    pause_task: Task = loop.create_task(periodically_pause(appstate))
    main_task: Task = loop.create_task(main(appstate))

    def shutdown():
        pause_task.cancel()
        main_task.cancel()
        loop.stop()

    for s in [SIGINT, SIGTERM]:
        loop.add_signal_handler(s, shutdown)

    try:
        loop.run_forever()
    except KeyboardInterrupt:
        pass
    finally:
        loop.run_until_complete(pause_task)
        loop.run_until_complete(main_task)  # Give the tasks a chance to cleanup
        print("Shutdown completed...")
        loop.close()
